#include <stdio.h>
#include "d:\Desktop\夏思远的.h"
char w[3][3],y[3][3],b[3][3],o[3][3],g[3][3],r[3][3];
char temp[3],copy[3][3];
char step[250];
int y_num;
int 计数=0;
#define 如果 if
#define 否则 else if
#define 否 else
#define 循环 while
int input();
int white();
int second();
int yellow();
int last();
int yellow_count();
int side();
int output();
int main()
{
	input();

	white();
	printf("\n白面已还原\n");
	second();
	printf("\n第二层已还原\n");
	last();
	printf("\n\n\n简化版:\n");
	output();
	short check=0;
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<3;j++)
		{
			check+=(w[i][j]=='w');
		}
	}
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<3;j++)
		{
			check+=(b[i][j]=='b');
		}
	}
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<3;j++)
		{
			check+=(y[i][j]=='y');
		}
	}
	if(check==27)
	{
		printf("\nall done!\n");
	}
	else
	{
		printf("\nfail!\n");
	}
	getchar();
	return 0;
}

int U()
{
	int i,j;
	for(i=0;i<3;i++)
	{
		temp[i]=b[0][i];
	}
	for(i=0;i<3;i++)
	{
		b[0][i]=r[0][i];
	}
	for(i=0;i<3;i++)
	{
		r[0][i]=g[0][i];
	}
	for(i=0;i<3;i++)
	{
		g[0][i]=o[0][i];
	}
	for(i=0;i<3;i++)
	{
		o[0][i]=temp[i];
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			copy[i][j]=y[i][j];
		}
	}
	y[0][0]=copy[2][0];
	y[0][1]=copy[1][0];
	y[0][2]=copy[0][0];
	y[1][0]=copy[2][1];
	y[1][2]=copy[0][1];
	y[2][0]=copy[2][2];
	y[2][1]=copy[1][2];
	y[2][2]=copy[0][2];
	printf("U");
	step[计数]='U';
	计数++;
	return 0;
}

int _U()
{
	U();U();U();
	return 0;
}

int L()
{
	int i,j;
	for(i=0;i<3;i++)
	{
		temp[i]=y[i][0];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		y[i][0]=g[j][2];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		g[i][2]=w[j][0];
	}
	for(i=0;i<3;i++)
	{
		w[i][0]=b[i][0];
	}
	for(i=0;i<3;i++)
	{
		b[i][0]=temp[i];
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			copy[i][j]=o[i][j];
		}
	}
	o[0][0]=copy[2][0];
	o[0][1]=copy[1][0];
	o[0][2]=copy[0][0];
	o[1][0]=copy[2][1];
	o[1][2]=copy[0][1];
	o[2][0]=copy[2][2];
	o[2][1]=copy[1][2];
	o[2][2]=copy[0][2];
	printf("L");
	step[计数]='L';
	计数++;
	return 0;
}

int _L()
{
	L();L();L();
	return 0;
}

int R()
{
	int i,j;
	for(i=0;i<3;i++)
	{
		temp[i]=y[i][2];
	}
	for(i=0;i<3;i++)
	{
		y[i][2]=b[i][2];
	}
	for(i=0;i<3;i++)
	{
		b[i][2]=w[i][2];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		w[i][2]=g[j][0];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		g[j][0]=temp[i];
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			copy[i][j]=r[i][j];
		}
	}
	r[0][0]=copy[2][0];
	r[0][1]=copy[1][0];
	r[0][2]=copy[0][0];
	r[1][0]=copy[2][1];
	r[1][2]=copy[0][1];
	r[2][0]=copy[2][2];
	r[2][1]=copy[1][2];
	r[2][2]=copy[0][2];
	printf("R");
	step[计数]='R';
	计数++;
	return 0;
}

int _R()
{
	R();R();R();
	return 0;
}

int B()
{
	int i,j;
	for(i=0;i<3;i++)
	{
		temp[i]=y[0][i];
	}
	for(i=0;i<3;i++)
	{
		y[0][i]=r[i][2];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		r[i][2]=w[2][j];
	}
	for(i=0;i<3;i++)
	{
		w[2][i]=o[i][0];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		o[j][0]=temp[i];
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			copy[i][j]=g[i][j];
		}
	}
	g[0][0]=copy[2][0];
	g[0][1]=copy[1][0];
	g[0][2]=copy[0][0];
	g[1][0]=copy[2][1];
	g[1][2]=copy[0][1];
	g[2][0]=copy[2][2];
	g[2][1]=copy[1][2];
	g[2][2]=copy[0][2];
	printf("B");
	step[计数]='B';
	计数++;
	return 0;
}

int _B()
{
	B();B();B();
	return 0;
}

int D()
{
	int i,j;
	for(i=0;i<3;i++)
	{
		temp[i]=b[2][i];
	}
	for(i=0;i<3;i++)
	{
		b[2][i]=o[2][i];
	}
	for(i=0;i<3;i++)
	{
		o[2][i]=g[2][i];
	}
	for(i=0;i<3;i++)
	{
		g[2][i]=r[2][i];
	}
	for(i=0;i<3;i++)
	{
		r[2][i]=temp[i];
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			copy[i][j]=w[i][j];
		}
	}
	w[0][0]=copy[2][0];
	w[0][1]=copy[1][0];
	w[0][2]=copy[0][0];
	w[1][0]=copy[2][1];
	w[1][2]=copy[0][1];
	w[2][0]=copy[2][2];
	w[2][1]=copy[1][2];
	w[2][2]=copy[0][2];
	printf("D");
	step[计数]='D';
	计数++;
	return 0;
}

int _D()
{
	D();D();D();
	return 0;
}

int F()
{
	int i,j;
	for(i=0;i<3;i++)
	{
		temp[i]=y[2][i];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		y[2][i]=o[j][2];
	}
	for(i=0;i<3;i++)
	{
		o[i][2]=w[0][i];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		w[0][i]=r[j][0];
	}
	for(i=0,j=2;i<3;i++,j--)
	{
		r[i][0]=temp[i];
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			copy[i][j]=b[i][j];
		}
	}
	b[0][0]=copy[2][0];
	b[0][1]=copy[1][0];
	b[0][2]=copy[0][0];
	b[1][0]=copy[2][1];
	b[1][2]=copy[0][1];
	b[2][0]=copy[2][2];
	b[2][1]=copy[1][2];
	b[2][2]=copy[0][2];
	printf("F");
	step[计数]='F';
	计数++;
	return 0;
}

int _F()
{
	F();F();F();
	return 0;
}

int input()
{
	int i,j;
	printf("请输入魔方色块\n(w白,y黄,b蓝,o橙,g绿,r红)\n");
	puts("w:");
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			w[i][j]=getchar();
		}
	}
	getchar();
	puts("y:");
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			y[i][j]=getchar();
		}
	}
	getchar();
	puts("b:");
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			b[i][j]=getchar();
		}
	}
	getchar();
	puts("o:");
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			o[i][j]=getchar();
		}
	}
	getchar();
	puts("g:");
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			g[i][j]=getchar();
		}
	}
	getchar();
	puts("r:");
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			r[i][j]=getchar();
		}
	}
	getchar();
	return 0;
}

int white()
{
	int 角块=False;//用于判断角块是否归位，再进行最后一次判定

	//尝试建立白十字架
	//尝试从第二层棱块复原
	循环((b[1][0]=='w')||(b[1][2]=='w')||(r[1][0]=='w')||(r[1][2]=='w')||(g[1][0]=='w')||(g[1][2]=='w')||(o[1][0]=='w')||(o[1][2]=='w'))
	{
		如果((b[1][0]=='w')&&(y[1][0]!='w'))
		{
			_L();
		}
		否则((b[1][2]=='w')&&(y[1][2]!='w'))
		{
			R();
		}
		否则((r[1][0]=='w')&&(y[2][1]!='w'))
		{
			_F();
		}
		否则((r[1][2]=='w')&&(y[0][1]!='w'))
		{
			B();
		}
		否则((g[1][0]=='w')&&(y[1][2]!='w'))
		{
			_R();
		}
		否则((g[1][2]=='w')&&(y[1][0]!='w'))
		{
			L();
		}
		否则((o[1][0]=='w')&&(y[0][1]!='w'))
		{
			_B();
		}
		否则((o[1][2]=='w')&&(y[2][1]!='w'))
		{
			F();
		}
		否
		{
			U();
		}
	}
	//尝试从白面棱块复原
	循环((w[0][1]=='w')||(w[1][0]=='w')||(w[1][2]=='w')||(w[2][1]=='w'))
		{
			如果((y[0][1]!='w')&&(w[2][1]=='w'))
			{
				B();B();
			}
			否则((y[1][0]!='w')&&(w[1][0]=='w'))
			{
				L();L();
			}
			否则((y[1][2]!='w')&&(w[1][2]=='w'))
			{
				R();R();
			}
			否则((y[2][1]!='w')&&(w[0][1]=='w'))
			{
				F();F();
			}
			否
			{
				D();
			}
		}

	//尝试从第三层棱块复原
	十字架:
	循环((b[2][1]=='w')||(r[2][1]=='w')||(g[2][1]=='w')||(o[2][1]=='w'))
	{
		如果(b[2][1]=='w')
				{
					while(1)
					{
						如果(y[2][1]!='w')
						{
							F();U();_L();
							break;
						}
						否
						{
							U();
						}
					}
				}
		否则(r[2][1]=='w')
				{
					while(1)
					{
						如果(y[1][2]!='w')
						{
							R();U();_F();
							break;
						}
						否
						{
							U();
						}
					}
				}
		否则(g[2][1]=='w')
				{
					while(1)
					{
						如果(y[0][1]!='w')
						{
							B();U();_R();
							break;
						}
						否
						{
							U();
						}
					}
				}
		否则(o[2][1]=='w')
				{
					while(1)
					{
						如果(y[1][0]!='w')
						{
							L();U();_B();
							break;
						}
						否
						{
							U();
						}
					}
				}
	}
	//尝试从第一层棱块复原
	循环((b[0][1]=='w')||(r[0][1]=='w')||(g[0][1]=='w')||(o[0][1]=='w'))
	{
		如果(b[0][1]=='w')
				{
					F();F();
					goto 十字架;
				}
		否则(r[0][1]=='w')
				{
					R();R();
					goto 十字架;
				}
		否则(g[0][1]=='w')
				{
					B();B();
					goto 十字架;
				}
		否则(o[0][1]=='w')
				{
					L();L();
					goto 十字架;
				}
	}
	//尝试把白块移至白面
	循环((w[0][1]!='w')||(w[1][0]!='w')||(w[1][2]!='w')||(w[2][1]!='w'))
	{
		如果((b[0][1]=='b')&&(y[2][1]=='w'))
			{
				F();F();
			}
		否则((r[0][1]=='r')&&(y[1][2]=='w'))
			{
				R();R();
			}
		否则((g[0][1]=='g')&&(y[0][1]=='w'))
			{
				B();B();
			}
		否则((o[0][1]=='o')&&(y[1][0]=='w'))
			{
				L();L();
			}
		//((b[0][1]!='b') || (r[0][1]!='r') || (g[0][1]!='g') || (o[0][1]!='o')) && ( (y[0][1]=='w')||(y[1][0]=='w')||(y[1][2]=='w')||(y[2][1]=='w') )
		否则(((b[0][1]!='b')&&(y[2][1]=='w')) || ((r[0][1]!='r')&&(y[1][2]=='w')) || ((g[0][1]!='g')&&(y[0][1]=='w')) || ((o[0][1]!='o')&&(y[1][0]=='w')))
			{
				U();
			}
	}
	//尝试复原白色角块
	角块:
	//尝试从第一层右角复原
	循环((b[0][2]=='w')||(r[0][2]=='w')||(g[0][2]=='w')||(o[0][2]=='w'))
	{
		如果((b[0][2]=='w')&&(r[0][0]=='r'))
		{
			_F();_U();F();
		}
		否则((r[0][2]=='w')&&(g[0][0]=='g'))
		{
			_R();_U();R();
		}
		否则((g[0][2]=='w')&&(o[0][0]=='o'))
		{
			_B();_U();B();
		}
		否则((o[0][2]=='w')&&(b[0][0]=='b'))
		{
			_L();_U();L();
		}
		否
		{
			U();
		}
	}
	//尝试从第一层左角复原
	循环((b[0][0]=='w')||(r[0][0]=='w')||(g[0][0]=='w')||(o[0][0]=='w'))
	{
		如果((b[0][0]=='w')&&(o[0][2]=='o'))
		{
			_U();_L();U();L();
		}
		否则((o[0][0]=='w')&&(g[0][2]=='g'))
		{
			_U();_B();U();B();
		}
		否则((g[0][0]=='w')&&(r[0][2]=='r'))
		{
			_U();_R();U();R();
		}
		否则((r[0][0]=='w')&&(b[0][2]=='b'))
		{
			_U();_F();U();F();
		}
		否
		{
			U();
		}
	}
	//尝试从黄面角块复原
	循环((y[0][0]=='w')||(y[0][2]=='w')||(y[2][0]=='w')||(y[2][2]=='w'))
	{
		如果((y[0][0]=='w')&&((w[2][0]!='w')||(o[2][0]!='o')||(g[2][2]!='g')))
		{
			L();_U();_L();
			goto 角块;
		}
		否则((y[0][2]=='w')&&((w[2][2]!='w')||(r[2][2]!='r')||(g[2][0]!='g')))
		{
			_R();U();R();
			goto 角块;
		}
		否则((y[2][0]=='w')&&((w[0][0]!='w')||(b[2][0]!='b')||(o[2][2]!='o')))
		{
			_L();U();L();
			goto 角块;
		}
		否则((y[2][2]=='w')&&((w[0][2]!='w')||(b[2][2]!='b')||(r[2][0]!='r')))
		{
			R();_U();_R();
			goto 角块;
		}
		否
		{
			U();
		}
	}
	//尝试从第三层右侧复原
	循环((b[2][2]=='w')||(r[2][2]=='w')||(g[2][2]=='w')||(o[2][2]=='w'))
	{
		如果(b[2][2]=='w')
		{
			_F();_U();F();
			goto 角块;
		}
		否则(r[2][2]=='w')
		{
			_R();_U();R();
			goto 角块;
		}
		否则(g[2][2]=='w')
		{
			_B();_U();B();
			goto 角块;
		}
		否则(o[2][2]=='w')
		{
			_L();_U();L();
			goto 角块;
		}
	}
	//尝试从第三层左侧复原
	循环((b[2][0]=='w')||(r[2][0]=='w')||(g[2][0]=='w')||(o[2][0]=='w'))
	{
		如果(b[2][0]=='w')
		{
			_L();U();L();
			goto 角块;
		}
		否则(r[2][0]=='w')
		{
			_F();U();F();
			goto 角块;
		}
		否则(g[2][0]=='w')
		{
			_R();U();R();
			goto 角块;
		}
		否则(o[2][0]=='w')
		{
			_B();U();B();
			goto 角块;
		}
	}
	//尝试从白面错位角块复原
	循环( ((w[0][0]=='w')&&((b[2][0]!='b')||(o[2][2]!='o'))) || ((w[0][2]=='w')&&((b[2][2]!='b')||(r[2][0]!='r'))) || ((w[2][0]=='w')&&((g[2][2]!='g')||(o[2][0]!='o'))) || ((w[2][2]=='w')&&((g[2][0]!='g')||(r[2][2]!='r'))) )
	{
		如果((w[0][0]=='w')&&((b[2][0]!='b')||(o[2][2]!='o')))
		{
			_L();_U();L();
			goto 角块;
		}
		否则((w[0][2]=='w')&&((b[2][2]!='b')||(r[2][0]!='r')))
		{
			_F();_U();F();
			goto 角块;
		}
		否则((w[2][0]=='w')&&((g[2][2]!='g')||(o[2][0]!='o')))
		{
			_B();_U();B();
			goto 角块;
		}
		否则((w[2][2]=='w')&&((g[2][0]!='g')||(r[2][2]!='r')))
		{
			_R();_U();R();
			goto 角块;
		}
	}
	//尝试从第二层复原
	if(角块==False)
	{
		角块=True;
		goto 角块;
	}
	return 0;
}

int second()
{
	//尝试正常复原第二层
second:
	循环(((b[0][1]!='y')&&(y[2][1]!='y')) || ((r[0][1]!='y')&&(y[1][2]!='y')) || ((g[0][1]!='y')&&(y[0][1]!='y')) || ((o[0][1]!='y')&&(y[1][0]!='y')))
	{
		//尝试从第二层左边复原
		如果((b[0][1]=='b')&&(y[2][1]=='o'))
		{
			_U();_L();U();L();U();F();_U();_F();
		}
		否则((r[0][1]=='r')&&(y[1][2]=='b'))
		{
			_U();_F();U();F();U();R();_U();_R();
		}
		否则((g[0][1]=='g')&&(y[0][1]=='r'))
		{
			_U();_R();U();R();U();B();_U();_B();
		}
		否则((o[0][1]=='o')&&(y[1][0]=='g'))
		{
			_U();_B();U();B();U();L();_U();_L();
		}
		//尝试从第二层右边复原
		否则((b[0][1]=='b')&&(y[2][1]=='r'))
		{
			U();R();_U();_R();_U();_F();U();F();
		}
		否则((r[0][1]=='r')&&(y[1][2]=='g'))
		{
			U();B();_U();_B();_U();_R();U();R();
		}
		否则((g[0][1]=='g')&&(y[0][1]=='o'))
		{
			U();L();_U();_L();_U();_B();U();B();
		}
		否则((o[0][1]=='o')&&(y[1][0]=='b'))
		{
			U();F();_U();_F();_U();_L();U();L();
		}
		否
		{
			U();
		}
	}
	//尝试从第二层左边错位块复原
	循环(((b[1][0]=='o')&&(o[1][2]=='b')) || ((r[1][0]=='b')&&(b[1][2]=='r')) || ((g[1][0]=='r')&&(r[1][2]=='g')) || ((o[1][0]=='g')&&(g[1][2]=='o')))
	{
		如果((b[1][0]=='o')&&(o[1][2]=='b'))
		{
			_L();U();L();U();F();_U();_F();
			U();_L();U();L();U();F();_U();_F();
			goto second;
		}
		否则((r[1][0]=='b')&&(b[1][2]=='r'))
		{
			_F();U();F();U();R();_U();_R();
			U();_F();U();F();U();R();_U();_R();
			goto second;
		}
		否则((g[1][0]=='r')&&(r[1][2]=='g'))
		{
			_R();U();R();U();B();_U();_B();
			U();_R();U();R();U();B();_U();_B();
			goto second;
		}
		否则((o[1][0]=='g')&&(g[1][2]=='o'))
		{
			_B();U();B();U();L();_U();_L();
			U();_B();U();B();U();L();_U();_L();
			goto second;
		}
	}
	//尝试从第二层右边错位块复原
	循环(((b[1][2]=='r')&&(r[1][0]=='b')) || ((r[1][2]=='g')&&(g[1][0]=='r')) || ((g[1][2]=='o')&&(o[1][0]=='g')) || ((o[1][2]=='b')&&(b[1][0]=='o')))
	{
		如果((b[1][2]=='r')&&(r[1][0]=='b'))
		{
			R();_U();_R();_U();_F();U();F();
			_U();R();_U();_R();_U();_F();U();F();
			goto second;
		}
		否则((r[1][2]=='g')&&(g[1][0]=='r'))
		{
			B();_U();_B();_U();_R();U();R();
			_U();B();_U();_B();_U();_R();U();R();
			goto second;
		}
		否则((g[1][2]=='o')&&(o[1][0]=='g'))
		{
			L();_U();_L();_U();_B();U();B();
			_U();L();_U();_L();_U();_B();U();B();
			goto second;
		}
		否则((o[1][2]=='b')&&(b[1][0]=='o'))
		{
			F();_U();_F();_U();_L();U();L();
			_U();F();_U();_F();_U();_L();U();L();
			goto second;
		}
	}
	return 0;//((b[0][1]!='y')&&(y[2][1]!='y')) || ((r[0][1]!='y')&&(y[1][2]!='y')) || ((g[0][1]!='y')&&(y[0][1]!='y')) || ((o[0][1]!='y')&&(y[1][0]!='y'))
}

int last()
{
	int a;
	int aa;
	循环(1)
	{
		yellow_count();
		a=(y_num!=9);
		aa=((b[0][0]!='b')||(b[0][1]!='b')||(r[0][0]!='r')||(r[0][1]!='r')||(g[0][0]!='g')||(g[0][1]!='g')||(o[0][0]!='o')||(o[0][1]!='o'));
		如果(a==1)
		{
			yellow();
		}
		否则(aa==1)
		{
			side();
		}
		否
		{
			break;
		}
	}
	/*
	循环((y_num!=9)||((b[0][0]!='b')||(r[0][0]!='r')||(g[0][0]!='g')||(o[0][0]!='o')))
	{
		如果(y_num!=9)
		{
			yellow();
		}
		否则((b[0][0]!='b')||(r[0][0]!='r')||(g[0][0]!='g')||(o[0][0]!='o'))
		{
			side();
		}
		yellow_count();
	}

	*/
	return 0;
}

//计算黄色面有多少黄块
int yellow_count()
{
	int i,j;
	y_num=0;
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			如果(y[i][j]=='y')
			{
				y_num++;
			}
		}
	}
	return 0;
}

//复原黄色面
int yellow()
{
	int safe=0;//防止找不到匹配的黄块一条线
	循环(y_num!=9)
	{
		如果((safe!=0)&&(safe%5==0))
		{
			U();
			safe++;
		}
		如果(safe==25)
		{
			printf("\nerror!\n");
			return 0;
		}
		如果((y_num==1)||(y_num==2))//无特殊，使用固定公式
		{
			F();R();U();_R();_U();_F();
		}
		否则((y_num==3)||(y_num==4))//可能有连成一条线的
		{
			如果((y[1][0]=='y')&&(y[1][2]=='y'))//=='y'
			{
				F();R();U();_R();_U();_F();
			}
			否则((y[0][1]=='y')&&(y[2][1]=='y'))//y=='y'
			{
				R();B();U();_B();_U();_R();
			}
			否//固定公式
			{
				F();R();U();_R();_U();_F();
			}
		}
		否则(y_num==5)//可能有十字，或者是连成一条线的
		{
			如果((y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y'))//形成十字
			{
				如果((b[0][0]=='y')&&(b[0][2]=='y'))//b面有两个黄块
				{
					_R();_U();R();_U();_R();U();U();R();
				}
				否则((r[0][0]=='y')&&(r[0][2]=='y'))//r面有两个黄块
				{
					_B();_U();B();_U();_B();U();U();B();
				}
				否则((g[0][0]=='y')&&(g[0][2]=='y'))//g面有两个黄块
				{
					_L();_U();L();_U();_L();U();U();L();
				}
				否则((o[0][0]=='y')&&(o[0][2]=='y'))//o面有两个黄块
				{
					_F();_U();F();_U();_F();U();U();F();
				}
			}
			否则((y[1][0]=='y')&&(y[1][2]=='y'))//存在一条线
			{
				F();R();U();_R();_U();_F();
			}
			否则((y[0][1]=='y')&&(y[2][1]=='y'))
			{
				R();B();U();_B();_U();_R();
			}
			否//固定公式
			{
				F();R();U();_R();_U();_F();
			}
		}
		否则(y_num==6)//可能有小鱼出现，或者是连成一条线
		{
			//b小鱼
			如果((y[0][0]=='y')&&(y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y'))
			{
				如果(b[0][0]=='y')
				{
					_R();_U();R();_U();_R();U();U();R();
				}
				否
				{
					F();U();_F();U();F();U();U();_F();
				}
			}
			//r小鱼
			否则((y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][0]=='y')&&(y[2][1]=='y'))
			{
				如果(r[0][0]=='y')
				{
					_B();_U();B();_U();_B();U();U();B();
				}
				否
				{
					R();U();_R();U();R();U();U();_R();
				}
			}
			//g小鱼
			否则((y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y')&&(y[2][2]=='y'))
			{
				如果(g[0][0]=='y')
				{
					_L();_U();L();_U();_L();U();U();L();
				}
				否
				{
					B();U();_B();U();B();U();U();_B();
				}
			}
			//o小鱼
			否则((y[0][1]=='y')&&(y[0][2]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y'))
			{
				如果(o[0][0]=='y')
				{
					_F();_U();F();U();_F();U();U();F();
				}
				否
				{
					L();U();_L();U();L();U();U();_L();
				}
			}
			否则((y[1][0]=='y')&&(y[1][2]=='y'))
			{
				F();R();U();_R();_U();_F();
			}
			否则((y[0][1]=='y')&&(y[2][1]=='y'))
			{
				R();B();U();_B();_U();_R();
			}
			否
			{
				F();R();U();_R();_U();_F();
			}
		}
		否则(y_num==7)//可能是“由”字，或者是双头鱼
		{
			如果((y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][0]=='y')&&(y[2][1]=='y')&&(y[2][2]=='y'))
			{
				_R();_U();R();_U();_R();U();U();R();
			}
			否则((y[0][1]=='y')&&(y[0][2]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y')&&(y[2][2]=='y'))
			{
				_B();_U();B();_U();_B();U();U();B();
			}
			否则((y[0][0]=='y')&&(y[0][1]=='y')&&(y[0][2]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y'))
			{
				_L();_U();L();_U();_L();U();U();L();
			}
			否则((y[0][0]=='y')&&(y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][0]=='y')&&(y[2][1]=='y'))
			{
				_F();_U();F();_U();_F();U();U();F();
			}
			/*
			否则((y[0][1]=='y')&&(y[0][2]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][0]=='y')&&(y[2][1]=='y'))
			{
				如果(r[0][0]=='y')
				{
					_R();_U();R();_U();_R();U();U();R();
				}
				否
				{
					_L();_U();L();_U();_L();U();U();L();
				}
			}
			否则((y[0][0]=='y')&&(y[0][1]=='y')&&(y[1][0]=='y')&&(y[1][2]=='y')&&(y[2][1]=='y')&&(y[2][2]=='y'))
			{
				如果(b[0][0]=='y')
				{
					_F();_U();F();_U();_F();U();U();F();
				}
				否
				{
					_B();_U();B();_U();_B();U();U();B();
				}
			}
			*/
			//否则((y[1][0]=='y')&&(y[1][2]=='y'))//不清楚有没有这种情况
			//{
			//	F();R();U();_R();_U();_F();
			//}
			//否则((y[0][1]=='y')&&(y[2][1]=='y'))//不清楚有没有这种情况
			//{
			//	R();B();U();_B();_U();_R();
			//}
			否则(((y[0][2]!='y')&&(y[2][0]!='y'))||((y[0][0]!='y')&&(y[2][2]!='y')))//双头鱼情况
			{
				_R();_U();R();_U();_R();U();U();R();
			}
			否
			{
				F();R();U();_R();_U();_F();
			}

		}
		safe++;
		yellow_count();
	}
	return 0;
}

//复原第三层边
int side()
{
	如果((b[0][0]!=b[0][2])&&(r[0][0]!=r[0][2])&&(g[0][0]!=g[0][2])&&(o[0][0]!=o[0][2]))//角块全部错位
	{
		R();R();F();F();_R();_B();R();F();F();_R();B();_R();
	}
	否则((b[0][0]==b[0][2])&&(r[0][0]!=r[0][2])&&(g[0][0]!=g[0][2])&&(o[0][0]!=o[0][2]))//仅b面完整
	{
		F();F();L();L();_F();_R();F();L();L();_F();R();_F();
	}
	否则((b[0][0]!=b[0][2])&&(r[0][0]==r[0][2])&&(g[0][0]!=g[0][2])&&(o[0][0]!=o[0][2]))//仅r面完整
	{
		R();R();F();F();_R();_B();R();F();F();_R();B();_R();
	}
	否则((b[0][0]!=b[0][2])&&(r[0][0]!=r[0][2])&&(g[0][0]==g[0][2])&&(o[0][0]!=o[0][2]))//仅g面完整
	{
		B();B();R();R();_B();_L();B();R();R();_B();L();_B();
	}
	否则((b[0][0]!=b[0][2])&&(r[0][0]!=r[0][2])&&(g[0][0]!=g[0][2])&&(o[0][0]==o[0][2]))//仅o面完整
	{
		L();L();B();B();_L();_F();L();B();B();_L();F();_L();
	}
	否则((b[0][0]==b[0][2])&&(r[0][0]==r[0][2])&&(g[0][0]==g[0][2])&&(o[0][0]==o[0][2]))//角块全部完整
	{
		如果((b[0][0]!=b[0][1])&&(r[0][0]!=r[0][1])&&(g[0][0]!=g[0][1])&&(o[0][0]!=o[0][1]))//棱块全部错位
		{
			_R();_U();R();_U();_R();U();U();R();
		}
		否则((b[0][0]==b[0][1])&&(r[0][0]!=r[0][1])&&(g[0][0]!=g[0][1])&&(o[0][0]!=o[0][1]))//仅b面完整
		{
			_R();_U();R();_U();_R();U();U();R();
		}
		否则((b[0][0]!=b[0][1])&&(r[0][0]==r[0][1])&&(g[0][0]!=g[0][1])&&(o[0][0]!=o[0][1]))//仅r面完整
		{
			_B();_U();B();_U();_B();U();U();B();
		}
		否则((b[0][0]!=b[0][1])&&(r[0][0]!=r[0][1])&&(g[0][0]==g[0][1])&&(o[0][0]!=o[0][1]))//仅g面完整
		{
			_L();_U();L();_U();_L();U();U();L();
		}
		否则((b[0][0]!=b[0][1])&&(r[0][0]!=r[0][1])&&(g[0][0]!=g[0][1])&&(o[0][0]==o[0][1]))//仅o面完整
		{
			_F();_U();F();_U();_F();U();U();F();
		}
		否//棱块全部完整
		{
			循环(b[0][1]!='b')
			{
				U();
			}
		}
	}
	return 0;
}

int output()
{
	int i=0;
	while(i<计数)
	{
		if((step[i]==step[i+1])&&(step[i+1]==step[i+2])&&(step[i+2]==step[i+3]))
		{
			step[i]='x';
			step[i+1]='x';
			step[i+2]='x';
			step[i+3]='x';
			i+=3;
		}
		i++;
	}
	i=0;
	while(i<计数)
	{
		if(step[i]!='x')
		{
			printf("%c",step[i]);
		}
		i++;
	}
	return 0;
}
